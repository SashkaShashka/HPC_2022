# Привет <img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/> </br>
## Содержимое репозитория и описание 
### Содержимое 
* В файле .h содержится код хоста и функция для последовательного умножения 2х матриц</br>
* В файле .cu содержится функция ядра</h5>
* Make файл используется для компоновки и представляетс собой файл с флагами</br>
* После компоновки, используя команду make код запускается с помощью команды ./MatMul m n k (размерности матриц 1-ая m\*n 2-ая n\*k)</br>
* В .cpp код на c++ для запуска на машине студента</br>
* В .cs код на C# для запуска на машине студента</br>
* В xlsx содержится таблица и графики результатов</br>
### Что распараллеливалось
Распараллеливалось именно умножение, где каждая нить занималась вычислением одного элемента выходной матрицы. 
### Описание файлов
#### .h 
1. Выделяется память для 4 массивов: A,B,C,C_linear и рандомно заполняются массивы А и В</br>
2. Выделяется память на GPU и копируются туда массивы</br>
3. После инициализации размерностей определяется количество блоков в гриде (блоки всегда имеют размер (32,32))</br>
4. Происходит запуск ядра</br>
5. Вычисление на GPU</br>
6. Копирования обратно на CPU</br>
7. Замер времени распараллеленного алгоритма</br>
8. Запуск последовательного алгоритма</br>
9. Замек времени </br>
10. Вычисление ускорения</br>
11. Вычисление ошибки</br>
12. Очищение памяти</br>
#### .cu 
1. Используется виртуальная архитектура CUDA для вычисления 1го и 2го индекса каждой нити</br>
2. Все матрицы объявляются и заполняются как одномерные вектора.</br>
3. Так как данные матрицы хранятся линейно, то чтобы не записывались "неправильные" данные ограничиваются индексы у нитей, которые могут вычислять c[i,j]</br>
4. Нити, которая вычисляют c[i,j], последовательно проходит по строке матрицы A и стоблцу матрицы B, прибавляя на каждом этапе их произведение ( C - изначельно инициализирована как нулевая матрица) </br>
## Эксперимент
### Постановка эксперимента</br>
Было решено провести помимо сравнения на сервере преподавателя последовательного алгоритма (с++) и параллельного (сuda) еще несколько. В сравнении участвовали последовательные алгоритмы на языке с++, с# и с# c использованием библиотеку из Nu-get пакетов DotNumerics.LinearAlgebr на машине студента.
### Среда выполнения
Процессор: AMD RYZEN 5800H (версия для ноутбука). </br>
Среда: VS 2022 в режиме Release.
### Эксперимент 
Был проведен ряд экспериментов с квадратными матрицами размерами 64\*64, 128\*128, 256\*256, 512\*512, 1024\*1024, 2048\*2048. Результаты сравнения приведены в таблицах. Для c# измерения производились в тиках и ms, для с++ и cuda в ms. </br></br>
Имеем следующие результаты: </br>
![image](https://user-images.githubusercontent.com/62326372/194389338-2885e024-b64e-4e84-b0c2-79bc7cedba2b.png) </br>
Сделаем предположение о том, что скорость работы C# и скорость работы С++ зависят друг от друга линейно. Так же предположим, что С++ на машине студента и сервере также линейно зависят. Тогда посчитаем во сколько раз С++ на сервере работает быстрее, чем на машине студента и во сколько раз С++ (на машине студента) на быстрее С#. Таким образом перемножив два этих числа получил соотношение скорости работ C++ на сервере и C# на машине студента.
Получим следующие результы. Будем считать, что отношение скоростей работы С# и С++ на сервере равно 0,326450128. </br>
![image](https://user-images.githubusercontent.com/62326372/194388231-98ac099d-5749-4704-b8b7-65c997cf17b9.png)</br>
Зная это число теперь можем посчитать примерное время работы алгоритмов С# на сервере. Получим следующую таблицу результатов: </br>
![image](https://user-images.githubusercontent.com/62326372/194389404-8f323800-5a14-4738-9560-dbb59494a3cb.png) </br>
### Итоговые результаты
График скорости выглядит следующим образом: </br>
![image](https://user-images.githubusercontent.com/62326372/194391090-2b473d20-a529-463e-a101-2fe35e5a47e3.png)
</br>
И cледующий для ускорения (все ускорения считались для значений по серверу): </br>
![image](https://user-images.githubusercontent.com/62326372/194392074-a2f9453d-31b1-4007-a936-efa4f4faa063.png) </br>

