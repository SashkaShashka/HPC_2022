# Привет <img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/> </br>
# Билатеральный фильтр
## Содержимое репозитория и описание 
### Содержимое 
* В файле .cpp и .h файлы библиотеки EasyBMP для работы с bmp изображениями</br>
* В файле .cu содержится функция ядра и основной код - было решено объединить для удобства</h5>
* Make файл используется для компоновки и представляетс собой файл с флагами</br>
* После компоновки, используя команду make код запускается с помощью команды ./SP (параметры)</br>
* В xlsx содержится таблица и графики результатов для Bilateral и Salt and Pepper</br>
* .ipynb питонвский файл для подготовки изображений </br>
### Что распараллеливалось
Распараллеливалась операция вычисления каждого пиксела. Каждая нить занималась вычислением своего пикселя. Вся остальная логика остается прежней и ничем не отличается от последовательной программы</br>
### Описание файлов
#### .ipynb 
Данный код был найден на просторах интернета и позволяет любое цвтеное jpg изображение преобразовать в оттенки серово и сделать шум соли и перца. </br>
#### .cu 
1. функция ядра с параметрами (G - массив для вычисления пикселя (константный, был на CPU прощитан), arrayOutput - выходной массив, texObj - объект текстурной памяти, width и height размеры изображения, sigmaR - параметр)</br>
1.1. Используется виртуальная архитектура CUDA для вычисления количества выделенных нитей и индекса для каждой нити</br>
1.2. Каждая нить вычисляет i-ый пиксель входного изображения по формуле из методички. </br>
2. moveCursor - функция перемещения курсора</br>
3. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
![image](https://user-images.githubusercontent.com/62326372/199138378-038c100c-9b62-4e1b-a3ed-4240936b896e.png)
Оригинал (версия в VS) самописного прогресс бара
![image](https://user-images.githubusercontent.com/62326372/199140859-cc1e244f-14bf-42a0-9b20-8d72bcf35f39.png)
![image](https://user-images.githubusercontent.com/62326372/199140884-27147fc4-2992-42b1-8f32-d6f1fbc7258d.png)
![image](https://user-images.githubusercontent.com/62326372/199140968-a971887d-eb3e-42e3-af49-51361a65bd39.png)
4. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
5. PrintProcent - заполнение прогресс бара</br>
6. GetGConst - просчет массива G</br>
7. MedianFilter - расчет отдельного пиксела</br>
8. transformationImage - преобразование всего изображения</br>
9. IsCudaSuccess - функция обработки ошибок</br>
10. Main</br>
10.1. Обработка входного изображения</br>
10.2. Обработка границ изображения</br>
10.3. Выделение памяти</br>
10.4. Выделение текстурной памятипамяти</br>
10.5. Запуск ядра -> Вычисление на GPU</br>
10.6. Копирования обратно на CPU</br>
10.7. Замер времени распараллеленного алгоритма</br>
10.8. Запуск последовательного алгоритма</br>
10.9. Замер времени</br>
10.10. Вычисление ускорения</br>
10.11. Очищение памяти</br>
## Эксперимент
### Постановка эксперимента</br>
Эксперименты проводилить стандартно на CUDA и С++ с размерами изображений 64x64, 128x128, 256x256, 512x512, 1024x1024. В качестве входных изображений были взяты изображения из интернета. Интересно, что мне так и не удалось запустить программу для изображений 64x64 и 128x128. 
![image](https://user-images.githubusercontent.com/62326372/199143251-a1f1513d-1f00-47be-8b38-ea870e741c10.png)
![image](https://user-images.githubusercontent.com/62326372/199143299-fb9adc60-758f-4210-b3f2-233979f25ad6.png)
![image](https://user-images.githubusercontent.com/62326372/199143347-d5e1f0c9-62ac-4081-b489-57e0f2a5f395.png)
### Убитое время, которое ни к чему не привело
Около 8 часов попыток понять, в чем проблема при работе с неквадратными изображениями... Я не понимаю, почему любое действие с массив все ломает. Если в ядре просто считать 9 элементов и в новый положить 4-ый, то все хорошо. Но если делаются какие-то преобразования, то получаются артфефакты наложения... Я так и не понял с чем это связано...</br>
### Эксперимент 
Имеем следующие результаты: </br>
![image](https://user-images.githubusercontent.com/62326372/199143568-8c2a74e1-b59f-48bc-87d8-89b199615945.png)
![image](https://user-images.githubusercontent.com/62326372/199143598-37fe5dbf-95af-498f-9eba-aaadb86d6fd0.png)
![image](https://user-images.githubusercontent.com/62326372/199143521-af91fb36-feeb-4857-910c-1fed0747021b.png)
</br>
![image](https://user-images.githubusercontent.com/62326372/199143651-2b591adf-62b2-45fc-b04d-56520784a020.png)</br>
Имеем следующий график ускорения: 
![image](https://user-images.githubusercontent.com/62326372/199143823-3f6bf0d4-e7ab-4002-86d1-c84af10e3c68.png) </br>
И следующий график времени выполения на CPU и GPU: 
![image](https://user-images.githubusercontent.com/62326372/199143891-6890a404-6cfe-43a3-9fad-3d55a50015db.png) </br>
### Итоговые выводы
Безусловно использовать CUDA для подобной задачи целесообразно. Ускорение, которое сотен тысяч, это ОЧЕНЬ солидный прирост производительности. Что анализировать? Каждая нить обрабатывает только один пиксель. Даже при размере 1024 на 1024 нитей в видеокарте хватает с лихвой, что и обеспечивает колоссальное ускорение. Не смотря на то, что операции не очень сложны, они очень долгие: обращение к памяти (самая долгая операция), сортировка (а это для каждого пикселя).
