# Привет <img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/> </br>
# Соль и перец
## Содержимое репозитория и описание 
### Содержимое 
* В файле .cpp и .h файлы библиотеки EasyBMP для работы с bmp изображениями</br>
* В файле .cu содержится функция ядра и основной код - было решено объединить для удобства</h5>
* Make файл используется для компоновки и представляетс собой файл с флагами</br>
* После компоновки, используя команду make код запускается с помощью команды ./SP (параметры)</br>
* В xlsx содержится таблица и графики результатов для Bilateral и Salt and Pepper</br>
* .ipynb питонвский файл для подготовки изображений </br>
### Что распараллеливалось
Распараллеливалась операция вычисления каждого пиксела. Каждая нить занималась вычислением своего пикселя. Вся остальная логика остается прежней и ничем не отличается от последовательной программы</br>
### Описание файлов
#### .ipynb 
Данный код был найден на просторах интернета и позволяет любое цвтеное jpg изображение преобразовать в оттенки серого и сделать шум соли и перца. </br>
#### .cu 
1. функция ядра с параметрами (G - массив для вычисления пикселя (константный, был на CPU прощитан), arrayOutput - выходной массив, texObj - объект текстурной памяти, width и height размеры изображения)</br>
1.1. Используется виртуальная архитектура CUDA для вычисления количества выделенных нитей и индекса для каждой нити</br>
1.2. Каждая нить вычисляет i-ый пиксель входного изображения по формуле из методички. </br>
2. moveCursor - функция перемещения курсора</br>
3. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
4. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
5. PrintProcent - заполнение прогресс бара</br>
![image](https://user-images.githubusercontent.com/62326372/199138378-038c100c-9b62-4e1b-a3ed-4240936b896e.png)
Оригинал (версия в VS) самописного прогресс бара
![image](https://user-images.githubusercontent.com/62326372/199140859-cc1e244f-14bf-42a0-9b20-8d72bcf35f39.png)
![image](https://user-images.githubusercontent.com/62326372/199140884-27147fc4-2992-42b1-8f32-d6f1fbc7258d.png)
![image](https://user-images.githubusercontent.com/62326372/199140968-a971887d-eb3e-42e3-af49-51361a65bd39.png)
6. MedianFilter - расчет отдельного пиксела</br>
7. transformationImage - преобразование всего изображения</br>
8. IsCudaSuccess - функция обработки ошибок</br>
9. Main</br>
9.1. Обработка входного изображения</br>
9.2. Обработка границ изображения</br>
9.3. Выделение памяти</br>
9.4. Выделение текстурной памятипамяти</br>
9.5. Запуск ядра -> Вычисление на GPU</br>
9.6. Копирования обратно на CPU</br>
9.7. Замер времени распараллеленного алгоритма</br>
9.8. Запуск последовательного алгоритма</br>
9.9. Замер времени</br>
9.10. Вычисление ускорения</br>
9.11. Очищение памяти</br>
## Эксперимент
### Постановка эксперимента</br>
Эксперименты проводилить стандартно на CUDA и С++ с размерами изображений 64x64, 128x128, 256x256, 512x512, 1024x1024. В качестве входных изображений были взяты изображения из интернета и предобработаны с помощью скрипта на питоне (файл приложен). Интересно, что мне так и не удалось запустить программу для изображений 64x64 и 128x128. 
![image](https://user-images.githubusercontent.com/62326372/199143251-a1f1513d-1f00-47be-8b38-ea870e741c10.png)
![image](https://user-images.githubusercontent.com/62326372/199143299-fb9adc60-758f-4210-b3f2-233979f25ad6.png)
![image](https://user-images.githubusercontent.com/62326372/199143347-d5e1f0c9-62ac-4081-b489-57e0f2a5f395.png)
### Убитое время, которое ни к чему не привело
Около 8 часов попыток понять, в чем проблема при работе с неквадратными изображениями... Я не понимаю, почему любое действие с массивом все ломает. Если в ядре просто считать 9 элементов и в новый положить 4-ый, то все хорошо. Но если делаются какие-то преобразования, то получаются артфефакты наложения... Я так и не понял с чем это связано...</br>
### Эксперимент 
Имеем следующие результаты: </br>
![image](https://user-images.githubusercontent.com/62326372/199143568-8c2a74e1-b59f-48bc-87d8-89b199615945.png)
![image](https://user-images.githubusercontent.com/62326372/199143598-37fe5dbf-95af-498f-9eba-aaadb86d6fd0.png)
![image](https://user-images.githubusercontent.com/62326372/199143521-af91fb36-feeb-4857-910c-1fed0747021b.png)
</br>
Моей целью не было как-то контроллировать шум, поэтому артефакты, которые получились на изображении размером 256х256 полностью оправданы. Это произошло из-за того, что в 9 пикселях встречалось много (больше или равно 5) черных или белых пикселей с чем алгоритм справиться не может.
</br>
И имеем более строгие цифры эксперимента:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146670-429e685e-06dd-4084-8bb3-837d0e62ac28.png)</br>
Имеем следующий график ускорения:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146706-105be1e1-a990-4e3b-a612-8a719947c7db.png)</br>
И следующий график времени выполения на CPU и GPU:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146737-09d4053d-7d58-47a1-9bee-ecf49c4f999e.png) </br>
### Итоговые выводы
Безусловно использовать CUDA для подобной задачи целесообразно. Ускорение, которое сотен тысяч, это ОЧЕНЬ солидный прирост производительности. Что анализировать? Каждая нить обрабатывает только один пиксель. Даже при размере 1024 на 1024 нитей в видеокарте хватает с лихвой, что и обеспечивает колоссальное ускорение. Не смотря на то, что операции не очень сложны, они очень долгие: обращение к памяти (самая долгая операция), сортировка (а это для каждого пикселя).
