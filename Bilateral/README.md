# Привет <img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/> </br>
# Билатеральный фильтр
## Содержимое репозитория и описание 
### Содержимое 
* В файле .cpp и .h файлы библиотеки EasyBMP для работы с bmp изображениями</br>
* В файле .cu содержится функция ядра и основной код - было решено объединить для удобства</h5>
* Make файл используется для компоновки и представляетс собой файл с флагами</br>
* После компоновки, используя команду make код запускается с помощью команды ./BilateralFilter sigmaD sigmaR (параметры)</br>
* В xlsx содержится таблица и графики результатов для Bilateral и Salt and Pepper</br>
### Что распараллеливалось
Распараллеливалась операция вычисления каждого пиксела. Каждая нить занималась вычислением своего пикселя. Вся остальная логика остается прежней и ничем не отличается от последовательной программы</br>
### Описание файлов
#### .cu 
1. функция ядра с параметрами (G - массив для вычисления пикселя (константный, был на CPU прощитан), arrayOutput - выходной массив, texObj - объект текстурной памяти, width и height размеры изображения, sigmaR - параметр)</br>
1.1. Используется виртуальная архитектура CUDA для вычисления количества выделенных нитей и индекса для каждой нити</br>
1.2. Каждая нить вычисляет i-ый пиксель входного изображения по формуле из методички. </br>
2. moveCursor - функция перемещения курсора</br>
3. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
![image](https://user-images.githubusercontent.com/62326372/199138378-038c100c-9b62-4e1b-a3ed-4240936b896e.png)
Оригинал (версия в VS) самописного прогресс бара
![image](https://user-images.githubusercontent.com/62326372/199140859-cc1e244f-14bf-42a0-9b20-8d72bcf35f39.png)
![image](https://user-images.githubusercontent.com/62326372/199140884-27147fc4-2992-42b1-8f32-d6f1fbc7258d.png)
![image](https://user-images.githubusercontent.com/62326372/199140968-a971887d-eb3e-42e3-af49-51361a65bd39.png)
4. draw_frame - рисование рамки для окна процентов для отображения процесса последовательной программы</br>
5. PrintProcent - заполнение прогресс бара</br>
6. GetGConst - просчет массива G</br>
7. BilateralFilter - расчет отдельного пиксела</br>
8. transformationImage - преобразование всего изображения</br>
9. IsCudaSuccess - функция обработки ошибок</br>
10. Main</br>
10.1. Обработка входного изображения</br>
10.2. Обработка границ изображения</br>
10.3. Выделение памяти</br>
10.4. Выделение текстурной памятипамяти</br>
10.5. Запуск ядра -> Вычисление на GPU</br>
10.6. Копирования обратно на CPU</br>
10.7. Замер времени распараллеленного алгоритма</br>
10.8. Запуск последовательного алгоритма</br>
10.9. Замер времени</br>
10.10. Вычисление ускорения</br>
10.11. Очищение памяти</br>
## Эксперимент
### Постановка эксперимента</br>
Эксперименты проводилить стандартно на CUDA и С++ с размерами изображений 64x64, 128x128, 256x256, 512x512, 1024x1024. В качестве входных изображений были взяты изображения из интернета.
![image](https://user-images.githubusercontent.com/62326372/199145712-ff65743d-843b-4d9c-8d8e-43c06bec4d4c.png)
![image](https://user-images.githubusercontent.com/62326372/199145749-78f31eb5-40f3-4fed-bb4b-9dd3a8915843.png)
![image](https://user-images.githubusercontent.com/62326372/199145774-e4e246f5-0c71-4abb-9f2a-23a627dede99.png)
![image](https://user-images.githubusercontent.com/62326372/199145792-1534346b-e795-4f4f-a362-3f036ab8eaca.png)
![image](https://user-images.githubusercontent.com/62326372/199145821-17604a0a-ad94-40ea-8acc-a988ce21e972.png)
### Убитое время, которое ни к чему не привело
Около 8 часов попыток понять, в чем проблема при работе с неквадратными изображениями... Я не понимаю, почему любое действие с массив все ломает. Если в ядре просто считать 9 элементов и в новый положить 4-ый, то все хорошо. Но если делаются какие-то преобразования, то получаются артфефакты наложения... Я так и не понял с чем это связано...</br>
### Эксперимент 
Имеем следующие результаты: </br>
![image](https://user-images.githubusercontent.com/62326372/199145955-edae8c5d-6c91-497e-a1cf-7214fb15af1d.png)
![image](https://user-images.githubusercontent.com/62326372/199145987-e4d8fe76-f7e6-48de-aa31-050fe1325953.png)
![image](https://user-images.githubusercontent.com/62326372/199146003-5797921b-db15-4648-a710-00df13240bc2.png)
![image](https://user-images.githubusercontent.com/62326372/199146025-b29f33c6-28f4-4cc3-ab3e-1e5f54e9e498.png)
![image](https://user-images.githubusercontent.com/62326372/199146055-ab9ae636-8d7f-418d-a819-94d2dc452fc4.png)
</br>
Подбирая сигмы можно достичь лучших результатов на тех или иных изображения. Я использовал, как мне кажется, средние значения, результат применения которых виден на всех изображениях.
</br>
И имеем более строгие цифры эксперимента:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146288-927c2034-7d82-4de3-80eb-d1725af71337.png) </br>
Имеем следующий график ускорения:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146315-730c5e20-c6f0-4fc9-bc6c-c464c87b0f45.png)</br>
И следующий график времени выполения на CPU и GPU:  </br>
![image](https://user-images.githubusercontent.com/62326372/199146366-9b03b77d-fa10-4fcc-8e6d-e3d0980e593d.png) </br>
### Итоговые выводы
Безусловно использовать куду для подобной задачи целесообразно. Ускорение, которое достигает тысяч, это ОЧЕНЬ солидный прирост производительности. Что анализировать? Каждая нить обрабатывает только один пиксель. Даже при размере 1024 на 1024 нитей в видеокарте хватает с лихвой, что и обеспечивает колоссальное ускорение. Операции, которые используются при расчете довольно сложны: возведение в степень и взятие экспоненты, поэтому распараллеливать подобные задачи необходимо.
